<!DOCTYPE html>
<html>
	<head>
		<title>Q ⟩ Qubit</title>
		<meta charset="utf-8">
		<meta name="viewport"             content="width=device-width,initial-scale=1.0">
		<meta name="description"          content="Quantum computing in your browser.">
		<meta name="copyright"            content="Stewart Smith 2019–2020">
		<meta name="keywords"             content="
			Q, Q.js, Q-js, Qjs, quantum JavaScript,
			quantum, quantum physics, quantum mechanics, superposition,
			quantum computer, quantum computer programming, quantum computing, QC, 
			quantum simulator, quantum computer simulator, 
			qubit, qbit, gate, Hadamard, Bloch, Bloch Sphere,
			Web, Web site, website, Web browser, browser, HTML, HTML5, JavaScript, ES6, CSS,
			Chrome, Firefox, Safari, Opera, Brave, Edge, WebKit, Blink, Gecko, Mozilla,
			Stewart Smith, Stewart, Stew, Stuart, Steven, Steve, Stewdio, stewartsmith, stew_rtsmith, @stew_rtsmith,
			Moar, Moar Technologies Corp, MTC,
			Google, IBM, Microsoft, Amazon, NASA, DWave, D-Wave,
			Quil, OpenQASM,
				ProjectQ, Qiskit, 
				Quantum Development Kit, Cirq, Strawberry Fields, t|ket>,
				QCL, Quantum pseudocode, Q#, Q|SI>, Q language, qGCL, QFC, QML, LIQUi|>, Quipper,
			Stanford CS 269 Q: Quantum Computer Programming">
		
		<meta name="twitter:card"         content="summary_large_image">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:title"        content="Q ⟩ Qubit">
		<meta name="twitter:description"  content="Quantum computing in your browser.">
		<meta name="twitter:image"        content="https://quantumjavascript.app/assets/Q-website-preview.jpg">
		
		<meta property="og:type"          content="website">
		<meta property="og:title"         content="Q ⟩ Qubit">
		<meta property="og:description"   content="Quantum computing in your browser.">
		<meta property="og:image"         content="https://quantumjavascript.app/assets/Q-website-preview.jpg">
		<meta property="og:url"           content="https://quantumjavascript.app/Qubit.html">
		
		<link rel="canonical" href="https://quantumjavascript.app/Qubit.html">
		<link href="assets/Q-favicon-064.png" rel="icon" type="image/png">
		<link href="assets/Q-favicon-144.png" rel="apple-touch-icon">
		
		<link rel="stylesheet" href="Q/Q.css">
		<link rel="stylesheet" href="Q/Q-Circuit-Editor.css">
		<link rel="stylesheet" href="assets/documentation.css">

		<script src="https://www.googletagmanager.com/gtag/js" async></script>
		<script src="assets/ga.js"></script>
		<script src="Q/Q.js"></script>
		<script src="Q/Q-ComplexNumber.js"></script>
		<script src="Q/Q-Matrix.js"></script>
		<script src="Q/Q-Qubit.js"></script>
		<script src="Q/Q-Gate.js"></script>
		<script src="Q/Q-History.js"></script>
		<script src="Q/Q-Circuit.js"></script>
		<script src="Q/Q-Circuit-Editor.js"></script>
		<script src="assets/navigation.js"></script>s

		<script src="assets/Three/three.105.min.js"></script>
		<script src="assets/Three/OrbitControls.js"></script>
		<script src="assets/Tween/tween.min.js"></script>
		<script src="assets/blochSphere.js"></script>
		<script src="assets/SurfaceText.js"></script>
			
	</head>
	<body>
		<main class="api">
			<p>
				Source code:
				<a href="https://github.com/stewdio/q.js/blob/master/source/Q-Qubit.js?ts=4" target="_blank">
					<code>Q-Qubit.js</code>
				</a>
			</p>
			<hr>
			<h3>Perfect pairs</h3>
			<p>
				A <a href="https://en.wikipedia.org/wiki/Qubit" target="_blank">qubit</a>
				is just a pair of numbers.
				That’s it—two 
				<a href="https://youtu.be/YYOKMUTTDdA" target="_blank">shiny happy number values,
				holding hands</a>.
				Let’s call the first number
				“<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>” 
				and the second one
				“<code><a href="Q-Qubit.html#this.beta">beta</a></code>.”
				We can couple this
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				together
				by storing them in a very small matrix
				that is 1 unit wide
				and 2 units tall.
				(See <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code> for a refresher on what a matrix is.)
				So when you think of a qubit you can imagine it as 
				a 1 × 2 <a href="Q-Matrix.html">matrix</a>
				containing its 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code> value on the top
				and its
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value on the bottom,
				like so:
			</p>
			<div class="center">
				<div class="matrix">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>alpha</td></tr>
						<tr><td>beta</td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				Because these two numbers 
				share a predictable relationship with each 
				other—which we’ll define in a moment—if 
				we know the value of one number 
				then we have a pretty good idea what the other’s value is.
				That is to say, if we know the 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				then we also know the 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>.
				(Or at least <code><a href="Q-Qubit.html#this.beta">beta</a></code>’s <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a>.)
				For this reason, when we discuss the value of a qubit
				we often only refer to one of these values instead of both.
				By convention the value we choose to represent a qubit
				is its 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value.
				So when we say “this qubit has a value of zero”
				what we’re really saying is that its 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value is <code>0</code>:
			</p>
			<div class="center maths">
				“zero” =
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>alpha: <strong>1</strong></td></tr>
						<tr><td>beta: <strong>0</strong></td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				Conversely, when we say “this qubit has a value of one”
				we’re claiming that its 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value is <code>1</code>:
			</p>
			<div class="center maths">
				“one” =
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>alpha: <strong>0</strong></td></tr>
						<tr><td>beta: <strong>1</strong></td></tr>
					</table>
				</div>
			</div>
			<br>
			<!--
			<h4>Vector form</h4>
			<p>
				<a href="https://en.wikipedia.org/wiki/Paul_Dirac" target="_blank">Paul Dirac</a>’s 
				With <a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket notation</a>
				offers us a more compact (and quantum-specific)
				means of describing qubit states.
				Let’s look again at the 
				<a href="Q-Matrix.html">matrix</a> form
				for a qubit in a “zero” state—again the
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code> value is on top
				and the
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value is on the bottom:
			</p>
			<div class="center maths">
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>1</td></tr>
						<tr><td>0</td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				With <a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket notation</a>
				we can rewrite the 
				<a href="Q-Matrix.html">matrix</a>
				in <a href="https://en.wikipedia.org/wiki/Row_and_column_vectors" target="_blank">vector form</a> like so:
			</p>
			<br>
			<div class="center">
				<span class="complex-vector alpha">1</span>
				<span class="complex-vector beta">0</span>
			</div>
			<br>
			<p>
				Notice how the 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code> value
				has moved from its position on the top of a matrix
				to the left-side of a vector.
				Similarly, the 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code> value
				has moved from its position on the bottom of a matrix
				to the right-side of a vector.
				We can reference the 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				separately without confusion, 
				writing them as
				<span class="complex-vector alpha">1</span>
				<span>and</span>
				<span class="complex-vector beta">0</span>
				respectively.
				The position and direction of the angle alphacbetas 
				let us know immediately which one is the
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				(<em>begins</em> with and angle alphacbeta pointing to the <em>left</em>)
				and which one is the
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				(<em>ends</em> with and angle alphacbeta pointing to the <em>right</em>).
			</p>
			<p>
				Because we often refer to a qubit’s value
				using only its 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>,
				we can describe a “zero” qubit as
				<span class="complex-vector beta">0</span>,
				and a “one” qubit as
				<span class="complex-vector beta">1</span>.
				That’s worth repeating as above:
			</p>
			<br>
			<div class="maths center">
				“zero” = 
				<span class="complex-vector beta">0</span>
			</div>
			<div class="center">
				“one” = 
				<span class="complex-vector beta">1</span>
			</div>
			<br>
			-->
			<h4 id="Predictable_couple">A predictable couple</h4>
			<p>
				The thing that makes this pair of numbers special
				is their relationship to each other.
				We can express this relationship as
				|<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>|<sup>2</sup> + 
				|<code><a href="Q-Qubit.html#this.beta">beta</a></code>|<sup>2</sup> = 1. 
				That is to the say, 
				the <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a> of
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				multiplied by the <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a> of 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>, 
				added to the <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a> of 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				multiplied by the <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a> of 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>,
				equals one.
				This is what defines a qubit.
				If a pair of numbers does <em>not</em> satisfy this equation
				then it cannot function as a qubit.
			</p>
			<p>
				Keen mathematical minds might be asking
				why we must take the <a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a> of a number
				before squaring it.
				Doesn’t multiplying a number by itself automatically yield an 
				<a href="https://en.wikipedia.org/wiki/Absolute_value" target="_blank">absolute value</a>?
				While that is true of <em>real</em> numbers,
				it is not true of of <em>complex</em> numbers.
				(See <code><a href="Q-ComplexNumber.html">ComplexNumber</a></code>
				for a refresher on this subject.)
			</p>
			<h4 id="Complex_couple">A complex couple</h4>
			<p>
				So far we’ve described qubits as containing
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				values ranging from <code>0</code> to <code>1</code>,
				and that remains true—but there’s more to the story.
				Qubits are actually made of 
				<a href="Q-ComplexNumber.html">complex number</a> pairs,
				meaning there is an <em>imaginary component.</em>
				(See <code><a href="Q-ComplexNumber.html">ComplexNumber</a></code>
				for a refresher on this subject.)
				So <em>one</em> qubit is actually made of <em>four</em> parts:
				The <code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				has a ① <code><a href="Q-ComplexNumber.html#this.real">real</a></code>
				component and an ②
				<code><a href="Q-ComplexNumber.html#this.imaginary">imaginary</a></code>
				one.
				The <code><a href="Q-Qubit.html#this.beta">beta</a></code>
				also has a ③ <code><a href="Q-ComplexNumber.html#this.real">real</a></code>
				component and an ④
				<code><a href="Q-ComplexNumber.html#this.imaginary">imaginary</a></code>
				one.
				(See <code><a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a></code> for more details.)
				This makes 
				<a href="Q-Qubit.html#Visualizing_qubit_states">visualizing qubit states</a> all the more interesting.
			</p>
			<h4>Superposition</h4>
			<p>
				You’ve probably heard the term 
				“<a href="https://en.wikipedia.org/wiki/Quantum_superposition" target="_blank">superposition</a>”—and along with that 
				you’ve likely been spoonfed some measure of mysticism; 
				<a href="https://youtu.be/CMdHDHEuOUE" target="_blank">pizza-bagels</a> and whatnot.
				In the real, physical world, superposition is indeed weird magic.
				But in quantum computing it’s dead simple.
				Superposition is any qubit state other than
				<span class="complex-vector ket">0</span>
				or
				<span class="complex-vector ket">1</span>.
				That’s it.
				That’s all there is to it.
			</p>
			<p>
				What the 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				values represent together are the 
				<a href="https://en.wikipedia.org/wiki/Probability_amplitude" target="_blank">probability amplitude</a> that a qubit,
				when measured, will be in either a
				<span class="complex-vector ket">0</span>
				or a
				<span class="complex-vector ket">1</span>
				state.
				Measurement itself causes a qubit’s
				<a href="https://en.wikipedia.org/wiki/Wave_function_collapse"  target="_blank">probability wave to collapse</a>,
				brining an end to its superposition.
				The probability that upon measurement a qubit’s
				<a href="https://en.wikipedia.org/wiki/Probability_amplitude" target="_blank">probability amplitude</a>
				will 
				<a href="#.prototype.collapse">collapse</a> to 
				<span class="complex-vector ket">0</span>
				is |<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>|<sup>2</sup>,
				while the probability that it will 
				<a href="#.prototype.collapse">collapse</a> to 
				<span class="complex-vector ket">1</span>
				is |<code><a href="Q-Qubit.html#this.beta">beta</a></code>|<sup>2</sup>.
			</p>
			<br>
			<ul>
				<li>
					A qubit, <code>{
						<a href="Q-Qubit.html#this.alpha">alpha</a>: 1,
						<a href="Q-Qubit.html#this.alpha">beta</a>: 0
					}</code>, has a 100% chance of collapsing to <span class="complex-vector ket">0</span>.
				</li>
				<li>
					A qubit, <code>{
						<a href="Q-Qubit.html#this.alpha">alpha</a>: 0,
						<a href="Q-Qubit.html#this.alpha">beta</a>: 1
					}</code>, has a 100% chance of collapsing to <span class="complex-vector ket">1</span>.
				</li>
				<li>
					A qubit, <code>{
						<a href="Q-Qubit.html#this.alpha">alpha</a>: 1÷√2,
						<a href="Q-Qubit.html#this.alpha">beta</a>: 1÷√2
					}</code>, 
					has a 50% chance of collapsing to <span class="complex-vector ket">0</span>
					and a 50% chance of collapsing to <span class="complex-vector ket">1</span>.
				</li>
			</ul>
			<br>
			<h3>Visualizing qubit states</h3>
			<p>
				Given the constraint
				|<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>|<sup>2</sup> + 
				|<code><a href="Q-Qubit.html#this.beta">beta</a></code>|<sup>2</sup> = 1, if we plot all of the possible <em>real</em>
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				values on a graph
				as <span class="symbol">x</span> and <span class="symbol">y</span> respectively,
				the outcome is a circle with a radius of 1 centered at the origin (0, 0); 
				ie. a <a href="https://en.wikipedia.org/wiki/Unit_circle)" target="_blank">unit circle</a>.
				All possible combinations of 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				lay on the perimeter of this circle.
			</p>
			<div class="unit-circle">
				<div class="unit-circle-outline"></div>
				<div class="unit-circle-spoke unit-circle-spoke-0"></div>
				<div class="unit-circle-spoke unit-circle-spoke-45"></div>
				<div class="unit-circle-spoke unit-circle-spoke-90"></div>
				<div class="unit-circle-spoke unit-circle-spoke-135"></div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-90">Vertical</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-45">Diagonal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-0">Horizontal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-315">Anti-diagonal</div>
				<div class="unit-circle-label unit-circle-label-angle-0">0˚</div>
				<div class="unit-circle-label unit-circle-label-angle-45">45˚</div>
				<div class="unit-circle-label unit-circle-label-angle-90">90˚</div>
				<div class="unit-circle-label unit-circle-label-angle-135">135˚</div>
				<div class="unit-circle-label unit-circle-label-angle-180">180˚</div>
				<div class="unit-circle-label unit-circle-label-angle-225">225˚</div>
				<div class="unit-circle-label unit-circle-label-angle-270">270˚</div>
				<div class="unit-circle-label unit-circle-label-angle-315">315˚</div>
				<div class="unit-circle-label unit-circle-label-point-0">1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-45">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-90">0, 1</div>
				<div class="unit-circle-label unit-circle-label-point-135">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-180">-1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-225">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-270">0, -1</div>
				<div class="unit-circle-label unit-circle-label-point-315">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
			</div>
			<h4 id="Bloch_sphere">The Bloch sphere</h4>
			<p>
				But a qubit isn’t just a pair of <em>real</em> numbers—it’s a pair of <a href="Q-ComplexNumber.html">complex numbers</a> and plotting the relationship of these values requires a third dimension.
				This transforms our unit circle with a radius of 1 in to a
				<a href="https://en.wikipedia.org/wiki/Bloch_sphere" target="_blank">Bloch sphere</a>,
				also with a radius of 1.
				<!--

				THIS IS A TERRIBLE AND INACCURATE EXPLANATION!
				MUST COME BACK AND RE-WRITE, FOCUS ON THE MATH!

				If you’re familiar with complex numbers you may expect them to add <em>two</em> dimensions to our unit circle rather than one.
				By taking the absolute value of <span class="symbol">a</span> or <span class="symbol">b</span>
				we effectively cancel out this extra dimension.
				-->
			</p>
			<br>
			<p>
				Select a qubit state:
			</p>
			<div id="bloch-sphere-qubits"></div>
			<p>
				Select a gate to apply:
			</p>
			<div id="bloch-sphere-gates"></div>
			<div class="interactive-container" id="bloch-sphere">
				<div class="interactive-component" id="bloch-angles">
					<code>
						<a href="Q-Qubit.html#this.alpha">alpha</a> = <span id="bloch-alpha">—</span><br>
						<a href="Q-Qubit.html#this.beta" >beta&nbsp;</a> = <span id="bloch-beta">—</span>
					</code><br>
					<br>
					<code><span id="bloch-theta">—</span>˚</code> polar angle θ (theta)<br>
					<code><span id="bloch-phi">—</span>˚</code> azimuth angle ϕ (phi)
				</div>
			</div>
			<p>
				Click and drag the Bloch Sphere to rotate it.
			</p>
			<hr>
			<h3>Constructor</h3>
			<p>
				<span class="constructor">Qubit</span>
				<code class="value-type">Function([ <a href="Q.html">Q</a>.Matrix* ][ 
					alpha: Number or <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>, 
					beta: Number or <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a> [, 
					label: String [, name: String ]]]) => <a href="Q.html">Q</a>.Qubit</code>
				<br>
				<code>Qubit</code>
				extends <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>
				and therefore inherits its 
				<a href="Q-Matrix.html#Static_properties">static</a> and 
				<a href="Q-Matrix.html#Prototype_properties">prototypal</a> properties.
				The <code>Qubit</code> constructor 
				can accept as a single argument a 
				<code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code> instance, 
				or anything that inherits from 
				<code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>—such as
				a <code><a href="Q.html">Q</a>.Qubit</code> instance—and will 
				return a new qubit constructed from the passed object’s values.
			</p>
			<p>
				Alternatively, the constructor
				expects two arguments that are each either
				instances of <code>Number</code> or 
				<code><a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a></code>
				which will will then correspond to the qubit’s 
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				values.
				Further, an optional third argument may be supplied for
				<code><a href="Q-Qubit.html#this.label">label</a></code>—expected 
				in the form of a single character <code>String</code>—to be
				used as a tiny label for the qubit when represented in diagram or graphic form. 
				Even further, an optional fourth argument may be supplied for
				<code><a href="Q-Qubit.html#this.name">name</a></code>—expected
				as a <code>String</code>—to be
				used as a more descriptive name for the qubit.
				If arguments for 
				<code><a href="Q-Qubit.html#this.label">label</a></code>
				or 
				<code><a href="Q-Qubit.html#this.name">name</a></code>
				are not supplied then
				the constructor checks against the list of existing 
				<code><a href="#.constants">constants</a></code>
				and if a qubit with matching
				<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>
				and 
				<code><a href="Q-Qubit.html#this.beta">beta</a></code>
				values is found then the corresponding
				<code><a href="Q-Qubit.html#this.label">label</a></code>
				and / or 
				<code><a href="Q-Qubit.html#this.name">name</a></code>
				will be copied to this new instance.
			</p>
			<p>
				When a new qubit is created it internally invokes the
				<code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code> constructor,
				such that <code>new <a href="Q.html">Q</a>.Qubit( 
					<a href="Q-Qubit.html#this.alpha">alpha</a>,
					<a href="Q-Qubit.html#this.beta">beta</a>
				)</code>
				is similar to
				<code>new <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>([ 
					<a href="Q-Qubit.html#this.alpha">alpha</a> ],
					[ <a href="Q-Qubit.html#this.beta">beta</a>
				])</code>.
				If the two supplied values do not satisfy the assertion that
				|<code><a href="Q-Qubit.html#this.alpha">alpha</a></code>|<sup>2</sup> + 
				|<code><a href="Q-Qubit.html#this.beta">beta</a></code>|<sup>2</sup> = 1 
				then an error is thrown.
			</p>
<pre><code>
var fox = new <a href="Q.html">Q</a>.Qubit( 1, 0 )
</code></pre>
			<ul class="properties">
				<li>
					<dt id="this.alpha">alpha</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a></code>
						The first of two values 
						that identify the state of a qubit.
					</dd>
				</li>
				<li>
					<dt id="this.beta">beta</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a></code>
						The second of two values 
						that identify the state of a qubit.
					</dd>
				</li>
				<li>
					<dt id="this.label">label</dt>
					<dd>
						<code class="value-type">String</code>
						Single character representing this qubit state, 
						for example ‘H’ for <a href="#.HORIZONTAL">horizontal</a>. 
						This can be passed to the constructor as an optional third argument 
						or automatically assigned based on existing <code><a href="Q.html">Q</a>.Qubit.<a href="#.constants">constants</a></code>
						If no match is found among existings constants the ‘?’ character is assigned.
					</dd>
				</li>
				<li>
					<dt id="this.name">name</dt>
					<dd>
						<code class="value-type">String</code>
						The name of the qubit state, assigned based on existing <code><a href="Q.html">Q</a>.Qubit.<a href="#.constants">constants</a></code>.
						If no match is found among existings constants the name is left empty.
					</dd>
				</li>
				<li>
					<dt id="this.index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						An identification number assigned to the instance based on the
						auto-incrementing static number <code><a href="Q.html">Q</a>.Qubit.<a href="#.index">index</a></code>.
						Used for minding the total number of instances created.
					</dd>
				</li>
			</ul>
			<hr>
			<h3>Static properties</h3>
			<p>
				Because <code>Q.Qubit</code> extends <code>Q.<a href="Q-Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing 
				<a href="Q-Matrix.html#Static_properties">static properties</a>.
			</p>
			<ul class="properties">
				<li>
					<dt id=".help">help</dt>
					<dd>
						<code class="value-type">Function ⇒ String</code>
						Calls and returns the value of 
						<code><a href="Q.html">Q</a>.<a href="#.help">help</a></code>,
						passing <code><a href="Q.html">Q</a>.Qubit</code> as the argument.
					</dd>
				</li>
				<li>
					<dt id=".index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						The number of instances created so far.
					</dd>
				</li>
			</ul>
			<h4>Constants and constant creation</h4>
			<ul class="properties">
				<li>
					<dt id=".constants">constants</dt>
					<dd>
						<code class="value-type">Object</code>
						Constants are appended <em>directly</em> to the 
						<code><a href="Q.html">Q</a>.Qubit</code> object.
						For convenience they are also appended to this
						<code><a href="Q.html">Q</a>.Qubit</code>.constants</code> object
						to make looking up constants in the JavaScript console trivial,
						and to make iterating across all constants convenient via functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
						<!-- Configured to be unwritable once appended via
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a></code>
						and they are labeled in uppercase to signal to us that this is so. -->
						The intention that a property act as a constant is signaled 
						by its labelling in all-uppercase.
					</dd>
				</li>
				<li>
					<dt id=".createConstant">createConstant</dt>
					<dd>
						<code class="value-type">Function( key: String, value: * )<!-- → undefined --></code>
						Appends a property named by <code>key</code> 
						with a value of <code>value</code>
						to both the 
						<code><a href="Q.html">Q</a>.Qubit</code> object 
						and its <code><a href="#.constants">constants</a></code> property.
					</dd>
				</li>
				<li>
					<dt id=".createConstants">createConstants</dt>
					<dd>
						<code class="value-type">Function( … )</code>
						Expects an even number of arguments.
						Will use each pair in the sequence of arguments to call
						<code><a href="#.createConstant">createConstant</a></code>.
					</dd>
				</li>
			</ul>
			<h4 id="Jones_Vectors">Constants — Jones Vectors</h4>
			<p>
				<code><a href="Q.html">Q</a>.Qubit</code> provides the following built-in <a href="https://en.wikipedia.org/wiki/Jones_calculus#Jones_vectors" target="_blank">Jones vectors</a>.
			</p>
			<ul class="properties">
				<li>
					<dt id=".HORIZONTAL">HORIZONTAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 1, 0, 'H', 'Horizontal' )</code>.
						Commonly thought of as “zero” or “off.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>1</td></tr>
								<tr><td>0</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".VERTICAL">VERTICAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 0, 1, 'V', 'Vertical' )</code>.
						Commonly thought of as “one” or “on.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>0</td></tr>
								<tr><td>1</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".DIAGONAL">DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, Math.SQRT1_2, 'D', 'Diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".ANTI_DIAGONAL">ANTI_DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, -Math.SQRT1_2, 'A', 'Anti-diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".RIGHT_HAND_CIRCULAR_POLARIZED">RIGHT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, -Math.SQRT1_2 ), 'R', 'Right-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-<span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".LEFT_HAND_CIRCULAR_POLARIZED">LEFT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, Math.SQRT1_2 ), 'L', 'Left-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td><span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
			</ul>
			<h4>Inspection</h4>
			<ul class="properties">
				<li>
					<dt id=".collapse">collapse</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.Qubit ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Returns a new <code><a href="Q.html">Q</a>.Qubit</code> randomly chosen to be either
						<code>new <a href="Q.html">Q</a>.Qubit( 1, 0 )</code> 
						— The <code><a href="#.HORIZONTAL">HORIZONTAL</a></code> constant —
						or
						<code>new <a href="Q.html">Q</a>.Qubit( 0, 1 )</code> 
						— The <code><a href="#.VERTICAL">VERTICAL</a></code> constant —
						based on the probability of the supplied qubit argument.
					</dd>
				</li>
				<li>
					<dt id=".applyGate">applyGate</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.Qubit ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Description TK.
					</dd>
				</li>
				<li>
					<dt id=".areEqual">areEqual</dt>
					<dd>
						<code class="value-type">Function( a: <a href="Q.html">Q</a>.Qubit, b: <a href="Q.html">Q</a>.Qubit ) ⇒ Boolean</code>
						If the <code><a href="#.alpha">alpha</a></code> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						and the <code><a href="#.beta">beta</code></a> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						then returns <code>true</code>, otherwise <code>false</code>.
					</dd>
				</li>
				<li>
					<dt id=".toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.Qubit ) ⇒ Object</code>
						Returns the following object for a given qubit’s probability state,
						useful for rendering a <a href="#Bloch_sphere">Bloch Sphere</a> representation.
<pre><code>
{
	theta, <span class="comment">//  Polar angle θ.</span>
	phi,   <span class="comment">//  Azimuth angle ϕ.</span>

	
	<span class="comment">//  Bloch vector,
	//  the surface point on a Bloch Sphere.</span>

	vector: { x, y, z },

	
	<span class="comment">//  Bloch vector “corrected”
	//  for Y-up coordinate systems.</span>

	position: {

		x: vector.<strong>y</strong>,<span class="comment">//  Note this Y here.</span>
		y: vector.<strong>z</strong>,<span class="comment">//  Note this Z here.</span>
		z: vector.<strong>x</strong> <span class="comment">//  Note this X here.</span>
	}
}
</code></pre>
					</dd>
				</li>
				<!--

					toXYZ
					fromBlochSphere
					fromXYZ

				-->
				<li>
					<dt id=".toText">toText</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.Qubit ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Description TK.
					</dd>
				</li>
				<li>
					<dt id=".findByBeta">findByBeta</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.Qubit ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Description TK.
					</dd>
				</li>
			</ul>
			<hr>
			<h3>Prototype properties</h3>
			<p>
				Because <code><a href="Q.html">Q</a>.Qubit</code> extends <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing prototype properties.
			</p>
			<h4>Non-destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.clone">clone</dt>
					<dd>
						<code class="value-type">Function ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Returns a new instance with the values for
						<code><a href="#this.real">alpha</a></code>
						and
						<code><a href="#this.imaginary">beta</a></code>
						copied from this instance.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse">collapse</dt>
					<dd>
						<code class="value-type">Function ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Calls and returns the result of the
						<a href="#.collapse"><code>collapse</code> static method</a>,
						passing the calling instance as an argument.
					</dd>
				</li>
				<li>
					<dt id=".prototype.applyGate">applyGate</dt>
					<dd>
						<code class="value-type">Function( gate: <a href="Q.html">Q</a>.Gate ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Description TK.
					</dd>
				</li>
				<li>
					<dt id=".prototype.isEqualTo">isEqualTo</dt>
					<dd>
						<code class="value-type">Function( otherQubit: <a href="Q.html">Q</a>.Qubit ) ⇒ Boolean</code>
						Calls and returns the result of the
						<a href="#.areEqual"><code>areEqual</code> static method</a>,
						passing the calling instance and <code>otherQubit</code> as arguments.
						Will not return a <code><a href="Q.html">Q</a>.Qubit</code> instance, 
						and therefore halts
						<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">“Fluent interface” method chaining</a>
						along this prototype.
					</dd>
				</li>
				<li>
					<dt id=".prototype.toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function ⇒ Object</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.toBlochSphere">toBlochSphere</a>( this )</code>.
						Will not return a <code><a href="Q.html">Q</a>.Qubit</code> instance, 
						and therefore halts
						<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">“Fluent interface” method chaining</a>
						along this prototype.
					</dd>
				</li>
				<li>
					<dt id=".prototype.toText">toText</dt>
					<dd>
						<code class="value-type">Function ⇒ String</code>
						Description TK.
						Will not return a <code><a href="Q.html">Q</a>.Qubit</code> instance, 
						and therefore halts
						<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">“Fluent interface” method chaining</a>
						along this prototype.
					</dd>
				</li>
			</ul>
			<h4>Destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.copy$">copy$</dt>
					<dd>
						<code class="value-type">Function( otherQubit: <a href="Q.html">Q</a>.Qubit ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Overwrites this instances’s
						<code><a href="Q-Matrix.html#this.rows">rows</a> Array</code>
						with that of 
						<code>otherQubit</code>.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse$">collapse$</dt>
					<dd>
						<code class="value-type">Function ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Expects no arguments.
						Calls the non-destructive <code><a href="#.prototype.collapse">collapse</a></code> method,
						then uses <code><a href="#.prototype.copy$">copy$</a></code> to overwrite
						this qubit’s values.
					</dd>
				</li>
				<li>
					<dt id=".prototype.applyGate$">applyGate$</dt>
					<dd>
						<code class="value-type">Function( gate: <a href="Q.html">Q</a>.Gate ) ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Description TK.
					</dd>
				</li>
			</ul>
		</main>
		<script>


var fox = new Q.Qubit( 1, 0 )


//  First, what do the docs have to say?

// console.log( '\n\nQ.Qubit\n\n', Q.Qubit.help(), '\n\n' )





/*

	O M F G

	Please forgive the below hideous code
	and interaction that goes with it.
	And the explainer text above that goes with it.
	This is SUCH A WORK IN PROGRESS RIGHT NOW!
	Coming back to fix shortly.

*/




//  First, what do the docs have to say?

//console.log( '\n\nQ.Qubit\n', Q.Qubit.help(), '\n\n' )













//  Create our Bloch Sphere explorer.

const
container = document.getElementById( 'bloch-sphere' ),
fov    = 45,
width  =  container.offsetWidth,
height =  container.offsetHeight,
aspect =  width / height,
near   = 0.1,
far    = 12,
scene  = new THREE.Scene(),
camera = new THREE.PerspectiveCamera( fov, aspect, near, far ),
renderer = new THREE.WebGLRenderer({ 

	// canvas: container,
	alpha: true,
	antialias: true
})

container.appendChild( renderer.domElement )
camera.position.z = 4
renderer.setPixelRatio( window.devicePixelRatio )
renderer.setSize( width, height )
scene.add( camera )


//  We’re going to pull a little trick here...
//  Let’s put our light in the opposite place of where we want it
//  because we’ll render the back face of the sphere
//  so light direction will be inverted.
//  We’ll also attach it to the camera
//  so the light doesn’t appear to move.


const light = new THREE.PointLight( 0xFFFFFF, 0.5, 0 )
light.position.set( -2, 6, 0 )
camera.add( light )
scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.8 ))


//  x

const sphere = new THREE.Group()
scene.add( sphere )


//  Create lines of latitude and longitude.

const grid = createQuadSphere({ radius: 1 })
sphere.add( grid )


//  x

const innards = new THREE.Mesh( 

	new THREE.SphereGeometry( 0.995, 32, 32 ),
	new THREE.MeshPhongMaterial({

		side: THREE.FrontSide,
		color: 0xE6E6E6,
		transparent: true,
		opacity: 0.8
	}) 
)
sphere.add( innards )




const yAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 2.5, 0.01, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x59A112 })
)
sphere.add( yAxis )

const xAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 0.01, 2.5 ),
	new THREE.MeshBasicMaterial({ color: 0xCF1717 })
)
sphere.add( xAxis )

const zAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 2.5, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x0F66BD })
)
sphere.add( zAxis )





const 
arrowLength     = 0.101,//  I know, weird, right?
arrowHeadLength = 0.1,
arrowHeadWidth  = 0.1

sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 1.0, 0 ), 
	new THREE.Vector3( 0, 1.25, 0 ), 
	arrowLength, 
	0x0F66BD, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 1.0, 0, 0 ), 
	new THREE.Vector3( 1.25, 0, 0 ), 
	arrowLength, 
	0x59A112, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 0, 1.0 ), 
	new THREE.Vector3( 0, 0, 1.25 ),
	arrowLength, 
	0xCF1717, 
	arrowHeadLength, 
	arrowHeadWidth
))





const axesLabelStyle = {

	width:   128,
	height:  128,
	fillStyle: '#000',
	font: 'bold italic 64px Georgia, "Times New Roman", serif'
}
const xAxisLabel = new SurfaceText( axesLabelStyle )
xAxisLabel.print( 'x' )
xAxisLabel.position.set( 0, 0, 1.45 )
xAxisLabel.scale.set( 0.002, 0.002, 0.002 )
xAxis.add( xAxisLabel )

const yAxisLabel = new SurfaceText( axesLabelStyle )
yAxisLabel.print( 'y' )
yAxisLabel.position.set( 1.45, 0, 0 )
yAxisLabel.scale.set( 0.002, 0.002, 0.002 )
yAxis.add( yAxisLabel )


const zAxisLabel = new SurfaceText( axesLabelStyle )
zAxisLabel.print( 'z' )
zAxisLabel.position.set( 0, 1.45, 0 )
zAxisLabel.scale.set( 0.002, 0.002, 0.002 )
zAxis.add( zAxisLabel )





//  The cone that points to the surface of the sphere.

const blochPointer = new THREE.Mesh(

	new THREE.CylinderBufferGeometry( 0, 0.5, 1, 32, 1 ),
	new THREE.MeshPhongMaterial({ color: 0xF2B90D })
)
blochPointer.geometry.translate( 0, -0.5, 0 )
blochPointer.geometry.rotateX( Math.PI / 2 )
blochPointer.geometry.scale( 0.2, 0.2, 0.2 )
blochPointer.lookAt( new THREE.Vector3() )
sphere.add( blochPointer )


//  The line from the sphere’s origin to its surface.

const blochVector = new THREE.Mesh(

	new THREE.BoxGeometry( 0.04, 0.04, 1 ),
	new THREE.MeshBasicMaterial({ color: 0xF2B90D })
)
blochVector.geometry.translate( 0, 0, 0.5 )
sphere.add( blochVector )


//  x

const
radius = 1.005,
// arcR = radius * Math.sin( bloch.theta ),
// arcH = radius * Math.cos( bloch.theta ),
arcR = radius * Math.sin( Math.PI / 2 ),
arcH = radius * Math.cos( Math.PI / 2 ),
thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

thetaGeometry.rotateX( Math.PI / 2 )
thetaGeometry.rotateY( Math.PI / 2 )
thetaGeometry.translate( 0, arcH, 0 )
const thetaRing = new THREE.Line( 

	thetaGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( thetaRing )


//  x

const
//arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI ),
arc = createLongitudeArc( radius, 64, 0, Math.PI * 2 ),
phiGeometry = arc.clone()

// phiGeometry.rotateY( bloch.phi )
const phiArc = new THREE.Line( 

	phiGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( phiArc )








const controls = new THREE.OrbitControls( camera, renderer.domElement )
controls.enableZoom = false
controls.enablePan = false





function changeBlochVector(){


	//  Are we ready for a change?

	if( qubitCurrent !== qubitTarget ||
		gateCurrent  !== gateTarget ){


		//  Deselect all buttons -- except the one in use!

		Array.from( document.getElementById( 'bloch-sphere-qubits' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-qubit' ) === qubitTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})
		Array.from( document.getElementById( 'bloch-sphere-gates' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-gate' ) === gateTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})


		//  x

		if( qubitCurrent === undefined ) qubitCurrent = qubitTarget
		if( gateCurrent  === undefined ) gateCurrent  = gateTarget

		const 
		currentState = qubitCurrent.applyGate( gateCurrent ), 
		currentBloch = currentState.toBlochSphere()
		targetState  = qubitTarget.applyGate( gateTarget ),
		targetBloch  = targetState.toBlochSphere()


		//  Update our alpha-beta readout.

		document.getElementById( 'bloch-alpha' ).innerText = targetState.alpha.toText( 4 )
		document.getElementById( 'bloch-beta' ).innerText = targetState.beta.toText( 4 )


		//  Tween our indicator to the target state.

		window.tween = new TWEEN.Tween({

				theta: currentBloch.theta,
				phi:   currentBloch.phi
			
			})//  Yes, this will be destructive to the blochState object.
			.to({

				theta: targetBloch.theta,
				phi:   targetBloch.phi
			
			}, 1000 )
			.easing( TWEEN.Easing.Quadratic.InOut )
			.onUpdate( updateBlochVector )
			.start()


		//  Make it ready to go for next time.

		qubitCurrent = qubitTarget
		gateCurrent  = gateTarget
	}
}








function updateBlochVector( input ){


	//  Move the big-ass surface pointer.

	blochPointer.position.set(
		
		Math.sin( input.theta ) * Math.sin( input.phi ),
		Math.cos( input.theta ),
		Math.sin( input.theta ) * Math.cos( input.phi )
	)
	blochPointer.lookAt( new THREE.Vector3() )


	blochVector.lookAt( blochPointer.getWorldPosition( new THREE.Vector3() ))


	//  Update our angles labels.
	
	document.getElementById( 'bloch-theta' ).innerText = ( input.theta * Q.RADIANS_TO_DEGREES ).toFixed()
	document.getElementById( 'bloch-phi' ).innerText = ( input.phi * Q.RADIANS_TO_DEGREES ).toFixed()


	const thetaSafe = Math.max( input.theta, 0.01 )
	thetaRing.scale.set(

		Math.sin( thetaSafe ),
		1,
		Math.sin( thetaSafe )
	)
	thetaRing.position.y = Math.cos( input.theta )


	
	//phiArc.rotateY( Math.PI - input.phi )
	phiArc.rotation.y = input.phi - Math.PI / 2




	/*
	const
	radius = 1,
	arcR = radius * Math.sin( bloch.theta ),
	arcH = radius * Math.cos( bloch.theta ),
	thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

	thetaGeometry.rotateX( Math.PI / 2 )
	thetaGeometry.rotateY( Math.PI / 2 )
	thetaGeometry.translate( 0, arcH, 0 )
	sphere.add( new THREE.Line( 

		thetaGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))



	const
	arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI )
	phiGeometry = arc.clone()
	
	phiGeometry.rotateY( bloch.phi )
	sphere.add( new THREE.Line( 

		phiGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))
	*/


	// blochVector.lookAt( blochCorrected )

	// mesh.position.copy( blochCorrected.clone().multiplyScalar( 10.1 + size / 2 ))

	//blochVectorLine.geometry.vertices[ 1 ].copy( blochCorrected.clone().multiplyScalar( 10.1 ))
	
	// const a = blochCorrected.clone()//.multiplyScalar( 10.1 )
	// blochVectorLine.geometry.setPositions([ 
	
	// 	0,  0, 0,  
	// 	a.x, a.y, a.z
	// ])
}











//  Create the qubit buttons.

let 
qubitTarget = Q.Qubit.HORIZONTAL,
qubitCurrent

const blochSphereQubits = document.getElementById( 'bloch-sphere-qubits' )
Object.keys( Q.Qubit.constants ).forEach( function( key ){

	const 
	qubit = Q.Qubit[ key ],
	qubitContainerElement = document.createElement( 'div' ),
	qubitElement = document.createElement( 'div' ),
	qubitNameElement = document.createElement( 'p' )
	
	qubitContainerElement.classList.add( 'bloch-sphere-qubit-container' )
	qubitContainerElement.setAttribute( 'data-qubit', qubit.name )
	qubitContainerElement.addEventListener( 'click', function(){

		qubitTarget = qubit
		changeBlochVector()
	})
	
	qubitElement.classList.add( 'bloch-sphere-qubit' )
	qubitElement.setAttribute( 'title', qubit.name )
	qubitElement.innerText = qubit.label
	qubitContainerElement.appendChild( qubitElement )

	qubitNameElement.innerText = qubit.name
	qubitContainerElement.appendChild( qubitNameElement )
	
	blochSphereQubits.appendChild( qubitContainerElement )
})




//  Create the gate buttons.

let 
gateTarget = Q.Gate.IDENTITY,
gateCurrent

const blochSphereGates = document.getElementById( 'bloch-sphere-gates' )
;[
	'IDENTITY',
	'HADAMARD',
	'PAULI_X',
	'PAULI_Y',
	'PAULI_Z',
	'PHASE',
	'PI_8'

].forEach( function( gateName ){

	const 
	gate = Q.Gate[ gateName ],
	gateContainerElement = document.createElement( 'div' ),
	gateElement = document.createElement( 'div' ),
	gateNameElement = document.createElement( 'p' )

	gateContainerElement.classList.add( 'bloch-sphere-gate-container' )
	gateContainerElement.setAttribute( 'data-gate',  gate.name )
	gateContainerElement.addEventListener( 'click', function(){

		gateTarget = gate
		changeBlochVector()
	})

	gateElement.classList.add( 'bloch-sphere-gate' )

	gateElement.setAttribute( 'title', gate.name )
	gateElement.innerText = gate.symbol
	gateContainerElement.appendChild( gateElement )

	gateNameElement.innerText = gate.name
	gateContainerElement.appendChild( gateNameElement )
	
	blochSphereGates.appendChild( gateContainerElement )
})











changeBlochVector()




sphere.rotation.x = 0.7
sphere.rotation.z = 0.2



const render = function(){

	requestAnimationFrame( render )
	controls.update()
	sphere.rotation.y += 0.0009;
	
	cameraWorldPosition = camera.getWorldPosition( new THREE.Vector3() )
	xAxisLabel.lookAt( cameraWorldPosition )
	yAxisLabel.lookAt( cameraWorldPosition )
	zAxisLabel.lookAt( cameraWorldPosition )

	renderer.render( scene, camera )
	TWEEN.update()
}

window.addEventListener( 'resize', function () {

	const
	width  = container.offsetWidth,
	height = container.offsetHeight
	
	camera.aspect = width / height
	camera.updateProjectionMatrix()
	renderer.setSize( width, height )

}, false )

render()







		</script>
	</body>
</html>
